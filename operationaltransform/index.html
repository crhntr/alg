<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
    <title>Operational Transformation</title>

    <script src="https://cdn.jsdelivr.net/npm/vue/dist/vue.js"></script>
  </head>
  <body>
    <div id="app">
      <div class="message">{{message}}</div>
      <textarea ref="textarea" @keyup="input" v-model="text"></textarea>
    </div>
  </body>
  <script>

  function getCookie(cname) {
      var name = cname + "="
      var decodedCookie = decodeURIComponent(document.cookie)
      var ca = decodedCookie.split(';')
      for(var i = 0; i <ca.length; i++) {
          var c = ca[i]
          while (c.charAt(0) == ' ') {
              c = c.substring(1)
          }
          if (c.indexOf(name) == 0) {
              return c.substring(name.length, c.length)
          }
      }
      return ""
  }

  function hex(buffer) {
    var hexCodes = []
    var view = new DataView(buffer)
    for (var i = 0; i < view.byteLength; i += 4) {
      // Using getUint32 reduces the number of iterations needed (we process 4 bytes each time)
      var value = view.getUint32(i)
      // toString(16) will give the hex representation of the number without padding
      var stringValue = value.toString(16)
      // We use concatenation and slice for padding
      var padding = '00000000'
      var paddedValue = (padding + stringValue).slice(-padding.length)
      hexCodes.push(paddedValue)
    }

    // Join all the hex strings into one
    return hexCodes.join("")
  }


    var app = new Vue({
      el: '#app',
      created () {
        if (!window["WebSocket"]) {
          this.message = 'Your browser does not support WebSockets'
          return
        }

        this.conn = new WebSocket("ws://" + document.location.host + "/ws")
        this.conn.onclose = evt => { this.message = 'socket closed' }
        this.conn.onmessage = (evt) => {
          console.log(JSON.parse(evt.data))
        }
      },
      beforeDestroy () { this.conn.close(1001, 'viewer navigating away') },
      data () {
        return {
          text: '',
          message: '',
          conn: null,
          selectionStart: 0,
          selectionEnd: 0,
          n: 0
        }
      },
      methods: {
        input: function (e) {
          this.n++

          const sid = getCookie('sid')

          if (!window['SubtleCrypto']) {
            var index = this.$refs.textarea.selectionStart
            var char = e.keyCode ? e.keyCode : e.which
            this.conn.send(JSON.stringify({char, index, hash}))
            return
          }
          const text = new TextEncoder("utf-8").encode(this.text)
          crypto.subtle.digest("SHA-256", text).then(hash => {
            var index = this.$refs.textarea.selectionStart
            var char = e.keyCode ? e.keyCode : e.which
            var hash = hex(hash)
            this.conn.send(JSON.stringify({char, index, hash, n: this.n, sid}))
          }, hashErr => {
            console.log(hashErr)
          })
        }
      }
    })
  </script>
</html>
