<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
    <title>Operational Transformation</title>

    <script src="https://cdn.jsdelivr.net/npm/vue/dist/vue.js"></script>
  </head>
  <body>
    <div id="app">
      <div class="message">{{message}}</div>
      <textarea ref="textarea" @keyup="input" v-model="text" :disabled="disable"></textarea>
    </div>
  </body>
  <script>

  const KeyBackspace = 8

  if (!String.prototype.splice) {
      /**
       * {JSDoc}
       *
       * The splice() method changes the content of a string by removing a range of
       * characters and/or adding new characters.
       *
       * @this {String}
       * @param {number} start Index at which to start changing the string.
       * @param {number} delCount An integer indicating the number of old chars to remove.
       * @param {string} newSubStr The String that is spliced in.
       * @return {string} A new string with the spliced substring.
       */
      String.prototype.splice = function(start, delCount, newSubStr) {
          return this.slice(0, start) + newSubStr + this.slice(start + Math.abs(delCount));
      };
  }

  function getCookie(cname) {
      var name = cname + "="
      var decodedCookie = decodeURIComponent(document.cookie)
      var ca = decodedCookie.split(';')
      for(var i = 0; i <ca.length; i++) {
          var c = ca[i]
          while (c.charAt(0) == ' ') {
              c = c.substring(1)
          }
          if (c.indexOf(name) == 0) {
              return c.substring(name.length, c.length)
          }
      }
      return ""
  }

  function hex(buffer) {
    var hexCodes = []
    var view = new DataView(buffer)
    for (var i = 0; i < view.byteLength; i += 4) {
      // Using getUint32 reduces the number of iterations needed (we process 4 bytes each time)
      var value = view.getUint32(i)
      // toString(16) will give the hex representation of the number without padding
      var stringValue = value.toString(16)
      // We use concatenation and slice for padding
      var padding = '00000000'
      var paddedValue = (padding + stringValue).slice(-padding.length)
      hexCodes.push(paddedValue)
    }

    // Join all the hex strings into one
    return hexCodes.join("")
  }


  function createNode (sid, len, index, previousHash) {

  }

  function apply (str, op) {
    console.log({str, op})
    return str.splice(op.index, op.len || 0, String.fromCharCode(op.val))
  }

  function commit (map, op) {

  }


    var app = new Vue({
      el: '#app',
      created () {
        this.sid = getCookie('sid') || Math.rand()

        if (!window["WebSocket"]) {
          this.message = 'Your browser does not support WebSockets'
          this.disable = true
          return
        }
        if (!window['SubtleCrypto']) {
          this.message = 'Your browser does not support SubtleCrypto'
          this.disable = true
          return
        }

        this.conn = new WebSocket("ws://" + document.location.host + "/ws")
        this.conn.onclose = evt => { this.message = 'socket closed' }

        this.conn.onmessage = (evt) => {
          const op = JSON.parse(evt.data)
          this.nodes[op.hash] = op

          function traverseUpdateChain (node, op) {
            console.log(node, op)
            if (!node.hash) {
              return String.fromCharCode(op.val)
            }
            if (node.hash === op.previousHash && node.hash !== op.hash) {
              return apply(op.text, node)
            }
            return traverseUpdateChain(this.nodes[node.previousHash], op)
          }

          var newText = traverseUpdateChain(this.head, op)
          if (newText !== this.head.text) {
            this.head = op
            this.text = newText
          }
        }
      },
      beforeDestroy () { this.conn.close(1001, 'viewer navigating away') },
      data () {
        return {
          nodes: {},
          disable: false,
          sid: '',
          text: '',
          message: '',
          conn: null,
          selectionStart: 0,
          selectionEnd: 0,
          n: 0,
          head: {hash: ''},
          previousLen: 0
        }
      },
      methods: {
        input: function (e) {

          var indexStart = this.$refs.textarea.selectionStart
          var indexEnd = this.$refs.textarea.selectionEnd
          var char = e.keyCode ? e.keyCode : e.which

          console.log({indexStart, indexEnd})

          var op = {
            sid: this.sid,
            len: this.previousLen,
            index: indexStart,
            previousHash: this.previousHash
          }

          console.log(e)

          switch (e.key) {
            case "Enter":
              op.val = char
              // fallthrough
            case "Backspace":
              op.type = e.key
              break;
            default:
              if (e.key.length !== 1) {
                return // ignore
              }
              op.type = "Input"
              op.val = char
          }

          const text = new TextEncoder("utf-8").encode(this.text)

          this.n++
          crypto.subtle.digest("SHA-256", text).then(hash => {
            var hash = hex(hash)
            op.hash = hash
            this.previousHash = hash

            op.n = this.n
            this.nodes[op.hash] = op
            this.conn.send(JSON.stringify(op))
          }, hashErr => {
            console.log(hashErr)
          })

          this.previousLen = indexEnd - indexStart
        }
      }
    })
  </script>
</html>
